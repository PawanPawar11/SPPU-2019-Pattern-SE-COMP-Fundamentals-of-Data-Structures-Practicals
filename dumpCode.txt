#include <iostream>

using namespace std;

struct Node {
  int data;
  Node* left;
  Node* right;

  Node(int data) {
    this->data = data;
    left = right = nullptr;
  }
};

class BinarySearchTree {
 private:
  Node* root;

  Node* insert(Node* node, int data) {
    if (node == nullptr) {
      return new Node(data);
    }

    if (data < node->data) {
      node->left = insert(node->left, data);
    } else if (data > node->data) {
      node->right = insert(node->right, data);
    }

    return node;
  }

  int longestPath(Node* node) {
    if (node == nullptr) {
      return 0;
    }

    int leftHeight = longestPath(node->left);
    int rightHeight = longestPath(node->right);

    return max(leftHeight, rightHeight) + 1;
  }

  int minVal(Node* node) {
    if (node == nullptr) {
      return -1; // Handle empty tree case
    }

    while (node->left != nullptr) {
      node = node->left;
    }

    return node->data;
  }

  void swapLeftRight(Node* node) {
    if (node == nullptr) {
      return;
    }

    swap(node->left, node->right);
    swapLeftRight(node->left);
    swapLeftRight(node->right);
  }

  Node* search(Node* node, int key) {
    if (node == nullptr || node->data == key) {
      return node;
    }

    if (key < node->data) {
      return search(node->left, key);
    } else {
      return search(node->right, key);
    }
  }

 public:
  BinarySearchTree() {
    root = nullptr;
  }

  void insert(int data) {
    root = insert(root, data);
  }

  int longestPath() {
    return longestPath(root);
  }

  int minVal() {
    return minVal(root);
  }

  void swapLeftRight() {
    swapLeftRight(root);
  }

  bool search(int key) {
    return search(root, key) != nullptr;
  }
};

int main() {
  BinarySearchTree bst;

  // Sample insertions
  bst.insert(50);
  bst.insert(30);
  bst.insert(20);
  bst.insert(40);
  bst.insert(70);
  bst.insert(60);
  bst.insert(80);

  // i. Insert a new node (e.g., 90)
  bst.insert(90);

  // ii. Find number of nodes in longest path
  cout << "Longest path length: " << bst.longestPath() << endl;

  // iii. Minimum data value found in the tree
  cout << "Minimum value: " << bst.minVal() << endl;

  // iv. Change a tree so that the roles of the left and right pointers are swapped at every node
  bst.swapLeftRight();

  // v. Search a value (e.g., 60)
  if (bst.search(60)) {
    cout << "60 found in the tree" << endl;
  } else {
    cout << "60 not found in the tree" << endl;
  }

  return 0;
}
